import Ember from 'ember';

const { inject: { service } } = Ember;
import { throttle } from '@ember/runloop';

import PathData from './path-data';

import AxisEvents from '../../utils/draw/axis-events';
import { stacks, Stacked } from '../../utils/stacks';
import { selectAxis, blockAdjKeyFn, blockAdjEltId, featureEltIdPrefix, featureNameClass, foregroundSelector, selectBlockAdj } from '../../utils/draw/stacksAxes';
import { targetNPaths, pathsFilter } from '../../utils/draw/paths-filter';

/* global d3 */



/*----------------------------------------------------------------------------*/

/** Used for CSS selectors targeting <g> and <path>-s generated by this component. */
const className = "blockAdj";
const CompName = 'components/axis-ticks-selected';

const trace_blockAdj = 1;

/*----------------------------------------------------------------------------*/
/* milliseconds duration of transitions in which alignment <path>-s between
 * features are drawn / changed, in particular the d attribute.
 * Match with time used by draw-map.js : zoom() and resetZoom() : 750.
 * also @see   dragTransitionTime and axisTickTransitionTime.
 * @see featureTrackTransitionTime
 */
const pathTransitionTime = 750;

/** Used for d3 attribute functions - return the datum of the element. */
function datumIdent(d) { return d; }

/** select the g.direct and g.alias within g.foreground > g.progress.
 * @see flowNames[]
 * @param flowName  undefined, or an element of flowNames[]
 */
function progressGroupsSelect(flowName) {
  /** if flowName is undefined, then select g.direct and g.alias.  refn flowNames[] */
  let classSelector = flowName ? '.' + flowName : '',
  selector = foregroundSelector + '> g.progress > g' + classSelector,
  g = d3.selectAll(selector);
  return g;
}

/*----------------------------------------------------------------------------*/

/**
 * @param blockAdj  [blockId0, blockId1]
 * @param drawMap for Evented - stack events
 */
export default Ember.Component.extend(Ember.Evented, AxisEvents, {
  /** AxisEvents is used to receive axis stacking and resize events.
   *  Evented may be used in future to propagate events to components rendered within block-adj.
   */
  store: service(),
  pathsP : service('data/paths-progressive'),
  flowsService: service('data/flows-collate'),

  needs: ['component:draw/path-data'],

  /** counters to debounce CFs */
  heightChanged : 0,
  axisStackChangedCount : 0,

  blockAdjId : Ember.computed.alias('blockAdj.blockAdjId'),
/*  ('blockAdj', function () {
    let blockAdj = this.get('blockAdj'),
    blockAdjId = blockAdj.get('blockAdjId');
    console.log(blockAdj, 'blockAdjId', blockAdjId);
    return blockAdjId;
  }),
*/
  axes :  Ember.computed.alias('blockAdj.axes'),

  pathsDensityParams : Ember.computed.alias('pathsP.pathsDensityParams'),
  pathsResultLength : Ember.computed(
    'blockAdj.pathsResult.[]', 'paths', 'pathsAliasesResultLength', 'pathsDensityParams',
    function () {
    /** Trigger paths request - side-effect. In the streaming case, result when
     * the stream ends is [], so paths{,Aliases}Result are used instead of the
     * result of this promise.
     */
    let pathsP = this.get('paths'),
    length = this.drawCurrent(pathsResultTypes.direct),
    pathsAliasesLength = this.get('pathsAliasesResultLength');
    return length;
  }),
  /** Used in paths{,Aliases}ResultLength().
   */
  drawCurrent : function(prType) {
    let
    /** e.g. 'pathsResult' or 'pathsAliasesResult' */
    pathsResult = this.get('blockAdj.' + prType.fieldName),
    fnName = prType.fieldName + 'Length',
    length = pathsResult && pathsResult.length;
    console.log(fnName, this, length);
    if (length) {
      let pathsDensityParams = this.get('pathsDensityParams'),
      axes = this.get('axes'),
      // axesDomains = this.get('blockAdj.axesDomains'),
      // Use the current zoom domain, not the overall domain, which is b.axis.domain.
      blockDomains =
        axes.mapBy('blocks')
        .reduce(function (bd, bb) {
          // if b.axis.axis1d.get('zoomed') is false, then domain will be undefined.
          // also b.axis.axis1d can be undefined, probably because of new axis, in which case it won't be zoomed yet (except when we add zoom domain to the URL).
          bb.forEach(function (b) { bd[b.axisName] = b.axis.axis1d && b.axis.axis1d.get('domain'); }); return bd; }, {}),
      axesRanges = axes.map((a) => a.yRange()),
      axisLengthPx = Math.max.apply(null, axesRanges),
      nPaths = targetNPaths(pathsDensityParams, axisLengthPx);
      if (pathsResult.length < nPaths) {
        /* a change of path density is not strictly a change of zoom, but is
         * close, and both require a new request. */
        this.incrementProperty('blockAdj.zoomCounter');
      } else if (pathsResult.length > nPaths) {
        // later may pass prType as a param to pathsFilter().
        pathsResult = pathsFilter(prType, pathsResult, blockDomains, nPaths);
      }
      /* The calling CPs paths{,Aliases}ResultLength() are called before didRender
       * and hence before drawGroup{,Container}().   .draw() uses the <g>-s they
       * maintain, so defer until end of run loop.
       */
      Ember.run.later( () => 
                       this.draw(/*pathsApiResultType*/ prType, pathsResult)
                     );
    }

    return length;
  },
  pathsAliasesResultLength : Ember.computed(
    'blockAdj.pathsAliasesResult.[]', 'paths', 'pathsDensityParams',
    function () {
    /* pathsAliasesResult is in a different form to pathsResult; passing it to
     * draw() requires some mapping, which is abstracted in 
     * pathsResultType e.g. pathsResultTypes.{direct,alias}
     */
    pathsApiResultType.flowName = pathsResultTypes.alias.flowName;
    pathsApiResultType.fieldName = pathsResultTypes.alias.fieldName;

    let pathsP = this.get('paths'),
    pathsAliasesLength = this.drawCurrent(pathsApiResultType /*pathsResultTypes.alias*/);

    return pathsAliasesLength;
  }),
  paths : Ember.computed('blockAdj', 'blockAdj.zoomCounter', function () {
    /** in the case of pathsViaStream, this promise will resolve with [] instead of the result -
     * blockAdj.pathsResult is passed to draw() instead.  */
    let pathsP = this.get('blockAdj.paths');
    console.log('blockAdj.paths', pathsP);
      if (false)
    pathsP.then(result => {
      console.log('blockAdj.paths', result);
    flowNames.forEach(flowName => {
      if (result[flowName])
        result[flowName].then((paths) => {
          /** pathsApiResultType could be identified as
           * pathsResultTypes.pathsApi; it is an input format which may be used
           * in multiple flows, so possibly .flowName should be separate from
           * pathsResultTypes[].
           */
          let pathsResultType = paths.length && paths[0].featureAObj ?
            pathsApiResultType /*pathsResultTypes.pathsApi*/ : pathsResultTypes[flowName];
          console.log('blockAdj.paths length', paths && paths.length, pathsResultType);
          if (paths && paths.length)
            throttle(this, this.draw, pathsResultType, paths, 200, false);
        });
    });
    });
    /** .direct and.alias are defined by the result of pathsP, not by pathsP, so
     * this would need to change; no purpose for this yet. */
    let resultP = (pathsP.direct && pathsP.alias) ?
    Ember.RSVP.allSettled([pathsP.direct, pathsP.alias])
      : (pathsP.direct || pathsP.alias);
    return pathsP;
  }),

  /*--------------------------------------------------------------------------*/

  isAdjacentToAxis(axisID) {
    let axes = this.get('axes'),
    match = (axes[0].axisName === axisID) || (axes[1].axisName === axisID);
    return match;
  },

  /*--------------------------------------------------------------------------*/

  didRender() {
    this._super(...arguments);
    let pM = this.drawGroupContainer();
    this.drawGroup(pM, true);
  },

  willDestroyElement() {
    // didDestroyElement() would also be OK
    console.log('willDestroyElement', this.get('blockAdjId'));
    let foreground = d3.selectAll(foregroundSelector);
    let pS = foreground
      // delete both g.direct and g.alias
      .selectAll('g > g.progress > g');
    this.drawGroup(pS, false);

    this._super(...arguments);
  },

  /** Give the flow control a handle of the g.progress > g for each flow, so
   * that flow-controls : action toggleVisible -> showVisible() can toggle
   * .hidden on this <g>.
   */
  connectFlowControl(flowName, g) {
    let flowsService = this.get('flowsService'),
    flows = flowsService.get('flows');
    console.log('connectFlowControl', flows, flows[flowName].g, g);
    flows[flowName].g = g;
  },

  /** Render the <g.progress><g.direct> which contains the <g.blockAdj> <g> <path>
   * rendered by this component. */
  drawGroupContainer() {
    let foreground = d3.selectAll(foregroundSelector);
    let ppS = foreground
      .selectAll('g > g.progress')
      .data([1]),
    ppA = ppS
      .enter()
      .append('g')
      .attr('class', 'progress'),
    ppM = ppS.merge(ppA),

    pS = ppM
      .selectAll('g > g.direct, g > g.alias') // @see flowNames[]
      .data(flowNames),
    me = this,
    pA = pS
      .enter()
      .append('g')
      .attr('class', datumIdent)
      .each(function (d, i, g) { console.log(this); me.connectFlowControl(d, d3.select(this)); } ),
    pM = pS.merge(pA);
    console.log('drawGroupContainer', pS.nodes(), pS.node());
    return pM;
  },
  /** Render the <g.blockAdj> which contains the <g><path>
   * @param pM  selection within which to append <g>; result of drawGroupContainer().
   * @param add  true to draw, false to remove
   */
  drawGroup(pM, add) {

    /* render the <g> for this block-adj */
    let
      blockAdjId = this.get('blockAdjId');

    let groupAddedClass = 'block-adj';
    let id = blockAdjEltId(blockAdjId);
    let gS = pM.selectAll('g' + '#' + id + '.' + className + '.' + groupAddedClass);
    /* could use .data(), given a list of all block adjacencies :
     * .data(flowsService.blockAdjs, blockAdjKeyFn); ... gS.enter() ... */
    if (add && gS.empty()) {
      let gA = pM
        .append('g')
        .datum(blockAdjId)
        .attr('id', blockAdjEltId)
        .attr('class', className + ' ' + groupAddedClass)
      ;
      console.log(gA.nodes(), gA.node(), this);
    }
    else if (! add && ! gS.empty()) {
      console.log('drawGroup remove', gS.nodes(), gS.node(), this);
      gS.remove();
    }
      
  },


  /**
   * @param pathsResultType e.g. pathsResultTypes.{Direct,Aliases}
   * @param paths grouped by features
   */
  draw (pathsResultType, featurePaths) {
    if (featurePaths.length === 0)
      return;
    pathsResultType.typeCheck(featurePaths[0]);

    /** blockAdjId is also contained in the result featurePaths
     */
    let
      blockAdjId = this.get('blockAdjId');

    /** Looking at just the first result, check the results blockIds match the
     * request blockAdjId. */
    let blockIds = resultBlockIds(pathsResultType, featurePaths[0]);
    if (blockIds.length) {
      /** blockAdjId is the order of Stacked / axes, whereas
       * featurePaths[0].alignment is in request order.
       * Requests (so far) are asymmetric, so blockAdjId[] and blockIds[] may be
       * in opposite order.
       */
      // const reversed = blockAdjId[0] > blockAdjId[1],
      function match(reversed) {
        let
          ok = (blockIds[0] === blockAdjId[0+reversed]) && (blockIds[1] === blockAdjId[1-reversed]);
        return ok;
      }
      let ok = match(false) || match(true);
      if (! ok)
        console.log('draw verify', blockAdjId, blockIds);
    }

    // let axisApi = this.get('drawMap.oa.axisApi');
    if (trace_blockAdj) {
      blockAdjId.forEach(function (blockId) {
        let axis = Stacked.getAxis(blockId);
        let aS = selectAxis(axis);
        console.log(blockId, aS.node());
      });
    }

    let dpS = progressGroupsSelect(pathsResultType.flowName);

    let baS = selectBlockAdj(dpS, blockAdjId);
    console.log(baS.nodes(), baS.node());
    
    if (baS.empty())
      console.log('draw', blockAdjId);
    else
    {
      let gS = baS.selectAll("g." + className)
        .data(featurePaths, pathsResultType.featurePathKeyFn);
      gS.exit().remove();

      let gA = gS.enter()
        .append('g')
        .attr('id', featureGroupIdFn) 
        .attr('class', className)
      ;
      function featureGroupIdFn(featurePath) {
        let id = resultBlockIds(pathsResultType, featurePath);
        return blockAdjEltId(id) + '_' + pathsResultType.featureEltId(featurePath);
      }


      let gSA = gS.merge(gA),
      owner = Ember.getOwner(this),
      pS = gSA
        .selectAll("path." + className)
        .data(pathsOfFeature(pathsResultType, owner), locationPairKeyFn),
      pSE = pS.enter()
        .append("path")
        .attr("class", className)
      ;
      let pSA = pS.merge(pSE);
      pSA
        .transition().duration(pathTransitionTime)
        .attr("d", function(d) { return d.pathU() /*get('pathU')*/; });
      // setupMouseHover(pSE);
      pS.exit().remove();
    }

  },

  /** Update the "d" attribute of the <path>-s.  */
  updatePathsPosition() {
    // based on draw().
    let dpS = progressGroupsSelect(undefined);
    let blockAdjId = this.get('blockAdjId');
    if (trace_blockAdj > 1)
      blockAdjId.forEach(function (blockId) {
        let axis = Stacked.getAxis(blockId);
        let y = stacks.oa.y[axis.axisName];
        console.log('updatePathsPosition axis', axis.axisName, y.domain(), axis, y.domain());
      });
    let baS = selectBlockAdj(dpS, blockAdjId);
    // let groupAddedClass = featurePaths[0]._id.name;
    //  + '.' + groupAddedClass
    let gS = baS.selectAll("g." + className),
    pS = gS
      .selectAll("path." + className);
    // Remove <path>s whose data refers to a block which has been removed from its axis.
    // later the block-adj will be removed, which will remove all contents.
    let removed = pS
      .filter(function (d) { return ! d.blocksHaveAxes(); });
    if (! removed.empty())
        console.log('updatePathsPosition removed', removed.nodes(), removed.node());
    removed.remove();
    pS = gS
      .selectAll("path." + className)
      // don't call pathU() if axes are gone.
      .filter(function (d) { return d.blocksHaveAxes(); });
    if (! pS.empty())
        console.log('updatePathsPosition before update pS', pS.nodes(), pS.node());
    /* now that paths are within <g.block-adj>, path position can be altered
     * during dragging by updating a skew transform of <g.block-adj>, instead of
     * repeatedly recalculating pathU.
     */
    pS
      .transition().duration(pathTransitionTime)
      // pathU() is temporarily a function, will revert to a computed function, as commented in path().
      .attr("d", function(d) { return d.pathU() /*get('pathU')*/; });
  },

  /*--------------------------------------------------------------------------*/

  axesDomains : Ember.computed.alias('blockAdj.axesDomains'),
  /** call updatePathsPosition().
   * filter / debounce the calls to handle multiple events at the same time.
   */
  updatePathsPositionDebounce : Ember.computed(
    'heightChanged', 'axisStackChangedCount',
    'axesDomains.0.0',
    'axesDomains.0.1',
    'axesDomains.1.0',
    'axesDomains.1.1',
    function () {
    let count = this.get('axisStackChangedCount'),
      heightChanged = this.get('heightChanged'),
      domainsChanged = this.get('axesDomains');
      console.log('updatePathsPositionDebounce', this.get('blockAdjId'), heightChanged, count, domainsChanged);
    this.updatePathsPosition();
    return count;
  }),


  /*--------------------------------------------------------------------------*/
  
  /** block-adj receives axisStackChanged and zoomedAxis from draw-map
   */

  resized : function(widthChanged, heightChanged, useTransition) {
    /* useTransition could be passed down to draw()
     * (also could pass in duration or t from showResize()).
     */
    console.log("resized in components/block-adj");
    /* In addition to the usual causes of repeated events, block-adj will
     * respond to events relating to 2 axes. */
    if (heightChanged)
      this.incrementProperty('heightChanged');
  },

  axisStackChanged : function() {
    console.log("axisStackChanged in components/block-adj");
    this.incrementProperty('axisStackChangedCount');
  },

  /** @param [axisID, t] */
  zoomedAxis : function(axisID_t) {
    let axisID = axisID_t[0],
    blockAdjId = this.get('blockAdjId'),
    axes = this.get('axes');
    if (trace_blockAdj > 1)
      console.log("zoomedAxis in ", CompName, axisID_t, blockAdjId, axes);
    /* zoomedAxis is specific to an axisID, so respond to that if
     * blockAdjId[0] or blockAdjId[1] are on this.axis.
     * resetZooms() does resetZoom(undefined) meaning un-zoom all axes, so match
     * if axisID is undefined.
     */
    if (!axisID || this.isAdjacentToAxis(axisID))
    {
      console.log('zoomedAxis matched', axisID, blockAdjId, axes);
      // paths positions are updated by event axisStackChanged() already received.
      // With zoom, the densityCount() result changes so request paths again
      this.incrementProperty('blockAdj.zoomCounter');
    }
  }
  /*--------------------------------------------------------------------------*/

  
});

if (false) {
  /** Example of param paths passed to draw() above. */
  const examplePaths = 
[{"_id":{"name":"myMarkerC"},
  "alignment":[
      {"blockId":"5c75d4f8792ccb326827daa2","repeats":{
	  "_id":{"name":"myMarkerC","blockId":"5c75d4f8792ccb326827daa2"},
	  "features":[{"_id":"5c75d4f8792ccb326827daa6","name":"myMarkerC","value":[3.1,3.1],"blockId":"5c75d4f8792ccb326827daa2","parentId":null}],"count":1}},
      {"blockId":"5c75d4f8792ccb326827daa1","repeats":{
	  "_id":{"name":"myMarkerC","blockId":"5c75d4f8792ccb326827daa1"},
	      "features":[{"_id":"5c75d4f8792ccb326827daa5","name":"myMarkerC","value":[0,0],"blockId":"5c75d4f8792ccb326827daa1","parentId":null}],"count":1}}]}];
}


/*----------------------------------------------------------------------------*/

function featureEltId(featureBlock)
{
  let id = featurePathKeyFn(featureBlock);
  id = featureNameClass(id);
  return id;
}

function featurePathKeyFn (featureBlock)
{ return featureBlock._id.name; }

/** Given the grouped data for a feature, from the pathsDirect() result,
 * generate the cross-product feature.alignment[0].repeats X feature.alignment[1].repeats.
 * The result is an array of pairs of features;  each pair defines a path and is of type PathData.
 * for each pair an element of pairs[] :
 *   pair.feature0 is in block pair.block0
 *   pair.feature1 is in block pair.block1
 *    (for the case of pathsResultTypes.direct) :
 *   pair.block0 === feature.alignment[0].blockId
 *   pair.block1 === feature.alignment[1].blockId
 * i.e. the path goes from the first block in the request params to the 2nd block
 * @param pathsResultType e.g. pathsResultTypes.{Direct,Aliases}
 * @param feature 1 element of the result array passed to draw()
 * @return [PathData, ...]
 */
function pathsOfFeature(pathsResultType, owner) {
  const PathData = owner.factoryFor('component:draw/path-data');
  return function (feature) {
    let blocksFeatures =
      [0, 1].map(function (blockIndex) { return pathsResultType.blocksFeatures(feature, blockIndex); }),
    blocks = resultBlockIds(pathsResultType, feature),
    pairs = 
      blocksFeatures[0].reduce(function (result, f0) {
        let result1 = blocksFeatures[1].reduce(function (result, f1) {
          let pair =
            PathData.create({
              feature0 : f0,
              feature1 : f1,
              block0 : blocks[0],
              block1 : blocks[1]
            });
          if (trace_blockAdj > 2)
            console.log('PathData.create()', PathData, pair);

          result.push(pair);
          return result;
        }, result);
        return result1;
      }, []);
    return pairs;
  };
}

function locationPairKeyFn(locationPair)
{
  return locationPair.feature0._id + '_' + locationPair.feature1._id;
}

/*----------------------------------------------------------------------------*/

const pathsApiFields = ['featureAObj', 'featureBObj'];
/** This type is created by paths-progressive.js : requestAliases() : receivedData() */
const pathsApiResultType = {
  // fieldName may be pathsResult or pathsAliasesResult
  typeCheck : function(resultElt) { if (! resultElt.featureAObj) {
    console.log('pathsApiResultType : typeCheck', resultElt); } },
  pathBlock :  function (resultElt, blockIndex) { return resultElt[pathsApiFields[blockIndex]].blockId; },
  /** direct.blocksFeatures() returns an array of features, so match that. See
   * similar commment in alias.blocksFeatures. */
  blocksFeatures : function (resultElt, blockIndex) { return [ resultElt[pathsApiFields[blockIndex]] ]; },
  featureEltId :
    function (resultElt)
    {
      let id = pathsApiResultType.featurePathKeyFn(resultElt);
      id = featureNameClass(id);
      return id;
    },
  featurePathKeyFn : function (resultElt) { return resultElt.featureA + '_' + resultElt.featureB; }

};

/** This is provision for using the API result type as <path> data type; not used currently because
 * the various forms of result data are converted to path-data.
 * These are the result types from :
 * Block/paths -> apiLookupAliases() ->  task.paths() 
 * Blocks/pathsViaStream  -> pathsAggr.pathsDirect() 
 * getPathsAliasesViaStream() / getPathsAliasesProgressive() -> Blocks/pathsAliasesProgressive -> dbLookupAliases() -> pathsAggr.pathsAliases()
 */
const pathsResultTypes = {
  direct : {
    fieldName : 'pathsResult',
    typeCheck : function(resultElt) { if (! resultElt._id) {
    console.log('direct : typeCheck', resultElt); } },
    pathBlock :  function (resultElt, blockIndex) { return resultElt.alignment[blockIndex].blockId; },
    blocksFeatures : function (resultElt, blockIndex) { return resultElt.alignment[blockIndex].repeats.features; },
    featureEltId : featureEltId,
    featurePathKeyFn : featurePathKeyFn
  },

  alias :
  {
    fieldName : 'pathsAliasesResult',
    typeCheck : function(resultElt) { if (! resultElt.aliased_features) {
    console.log('alias : typeCheck', resultElt); } },
    pathBlock :  function (resultElt, blockIndex) { return resultElt.aliased_features[blockIndex].blockId; },
    /** There is currently only 1 element in .aliased_features[blockIndex], but
     * pathsOfFeature() handles an array an produces a cross-product, so return
     * this 1 element as an array. */
    blocksFeatures : function (resultElt, blockIndex) { return [resultElt.aliased_features[blockIndex]]; },
    featureEltId :
    function (resultElt)
    {
      let id = pathsResultTypes.alias.featurePathKeyFn(resultElt);
      id = featureNameClass(id);
      return id;
    },
    featurePathKeyFn : function (resultElt) {
      return resultElt.aliased_features.map(function (f) { return f.name; } ).join('_');
    }
  }
},
/** This matches the index values of services/data/flows-collate.js : flows */
flowNames = Object.keys(pathsResultTypes);
// add .flowName to each of pathsResultTypes, which could later require non-const declaration.
flowNames.forEach(function (flowName) { pathsResultTypes[flowName].flowName = flowName; } );


function resultBlockIds(pathsResultType, featurePath) {
  let blockIds =
    [0, 1].map(function (blockIndex) { return pathsResultType.pathBlock(featurePath, blockIndex); });
  return blockIds;
}
